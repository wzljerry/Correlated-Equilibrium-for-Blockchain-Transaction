function Max_p=three_p_sum(s,T)
format short g
b = 0;
v = [5 5 5
    5 5 10
    5 10 5
    5 10 10
    10 5 5
    10 5 10
    10 10 5
    10 10 10];
% s = [200 300 300];  %需调整
% alpha = [3000 3000 3000];  %需调整
alpha=[3000:500:8000];
beta = [0.01 0.01 0.01];
T = [20 30 10];
a = s/100;  
% 前面是基本数据输入，只需调前面参数即可

n = length(v);  %矩阵v的行数
s = repmat(s,n,1);  %将s向量复制为6个一样的矩阵，下面5行一样道理。
a = repmat(a,n,1);
alpha = repmat(alpha,n,1);
beta = repmat(beta,n,1);
T = repmat(T,n,1);

p = exp(a.*v-b)./repmat(sum(exp(a.*v-b),2),1,3);   %计算p

u = p.*(alpha./(1+exp(-beta.*T)) - v.*s);          %计算u

f = sum(u,2);  %目标函数八个系数u1,u2,u3,u4，u5，u6,u7,u8

Aeq = [1 1 1 1 1 1 1 1];  %等式约束：8个pai加起来等式左边系数
beq = 1;          %等式约束：8个pai加起来等式右边系数
u = u';           %对u进行转至
A = -[u(1,1)-u(1,5), u(1,2)-u(1,6),u(1,3)-u(1,7),u(1,4)-u(1,8),0,0, 0, 0
     0, 0, 0,0,u(1,5)-u(1,1), u(1,6)-u(1,2),u(1,7)-u(1,3),u(1,8)-u(1,4)
     u(2,1)-u(2,3),u(2,2)-u(2,4),0,0,u(2,5)-u(2,7), u(2,6)-u(2,8),0,0
     0,0,u(2,3)-u(2,1),u(2,4)-u(2,2),0,0,u(2,7)-u(2,5),u(2,8)-u(2,6)
     u(3,1)-u(3,2),0,u(3,3)-u(3,4),0,u(3,5)-u(3,6),0,u(3,7)-u(3,8),0
     0,u(3,2)-u(3,1),0,u(3,3)-u(3,4),0,u(3,6)-u(3,5),0,u(3,8)-u(3,7)
     ];   %不等式约束六个方程矩阵大于0，加个负号小于0
b = zeros(6,1);                             %不等式约束六个方程向量
lb = zeros(8,1);  %四个优化变量大于等于0

[x,Min_p] = linprog(-f,A,b,Aeq,beq,lb);    %线性优化，最小值优化，所以加个负号
%x 
Max_p = -Min_p;
% x代表八个pai
% Min_p代表优化目标函数
end